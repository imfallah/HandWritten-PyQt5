{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contributing to HandWriter HandWriter is a project that is still in its infancy. It has successfully delivered on its basic premise, but many improvements are still desired. This documentation aims to make the HandWriter codebase easy to understand so that contributors may suitably modify it to deliver these improvements. Technologies Used Python PyQt5 - Used to write the desktop GUI fman-build-system (FBS) - Used with PyQt5 to write the desktop GUI, and for packaging and distribution. Refer to their documentation here . FBS critically requires Python 3.5 or 3.6, and PyInstaller 3.4 In fact, the whole project layout is based on FBS. To execute the app, type fbs run anywhere in the project. Documentation layout You can read more about the architecture here Or about feeding a new handwriting (or automating handwriting generation) here","title":"Home"},{"location":"#contributing-to-handwriter","text":"HandWriter is a project that is still in its infancy. It has successfully delivered on its basic premise, but many improvements are still desired. This documentation aims to make the HandWriter codebase easy to understand so that contributors may suitably modify it to deliver these improvements.","title":"Contributing to HandWriter"},{"location":"#technologies-used","text":"Python PyQt5 - Used to write the desktop GUI fman-build-system (FBS) - Used with PyQt5 to write the desktop GUI, and for packaging and distribution. Refer to their documentation here . FBS critically requires Python 3.5 or 3.6, and PyInstaller 3.4 In fact, the whole project layout is based on FBS. To execute the app, type fbs run anywhere in the project.","title":"Technologies Used"},{"location":"#documentation-layout","text":"You can read more about the architecture here Or about feeding a new handwriting (or automating handwriting generation) here","title":"Documentation layout"},{"location":"architecture/","text":"Architecture HandWriter follows the Object Oriented paradigm. The conversion of a document of text is done through multiple levels of abstraction. This allows the program to tackle arrangement and conversion problems at the stages where they are encountered. Inheritance is used to avoid multiple instances of the same data members through objects of each layer (a data member is thus initialized only once, saving memory). The class LineParser sits at the bottom of this architecture. It\u2019s methods parse_line() and parse_line_constrained() both directly use the hashes.pickle file and convert the line of text that is fed to them into a line of handwritten text, word by word, horizontally stacking each image of a letter to form the word. Furthermore, parse_line_constrained() has a parameter to constrain the number of characters in a line (which is what a line in a page is really like). When a word overflows this character limit, that word and the rest of the line is considered as leftover text, the rest of the line is filled with whitespace, and the image of the line and leftover text is returned. The class PageParser inherits from LineParser and is used to stack lines of text on top of each other. It has the method parse_page_constrained() , that parses a page similar to how the aforementioned constrained method parses a line - it stacks images of lines on top of each other and returns the image of a page and leftover text, filling in with whitespace as needed. The method parse_page_constrained() handles stacking leftover words from the previous line into the new line (this happens because you can type many more characters in a line than you would normally write on a page), and text alignment. The class DocumentParser inherits from PageParser and parses the whole document. It uses the python-docx module to read text and metadata from the document, then relays this information to PageParser methods. These methods return the pages of the document in handwriting which are then compiled into a PDF.","title":"Architecture"},{"location":"architecture/#architecture","text":"HandWriter follows the Object Oriented paradigm. The conversion of a document of text is done through multiple levels of abstraction. This allows the program to tackle arrangement and conversion problems at the stages where they are encountered. Inheritance is used to avoid multiple instances of the same data members through objects of each layer (a data member is thus initialized only once, saving memory). The class LineParser sits at the bottom of this architecture. It\u2019s methods parse_line() and parse_line_constrained() both directly use the hashes.pickle file and convert the line of text that is fed to them into a line of handwritten text, word by word, horizontally stacking each image of a letter to form the word. Furthermore, parse_line_constrained() has a parameter to constrain the number of characters in a line (which is what a line in a page is really like). When a word overflows this character limit, that word and the rest of the line is considered as leftover text, the rest of the line is filled with whitespace, and the image of the line and leftover text is returned. The class PageParser inherits from LineParser and is used to stack lines of text on top of each other. It has the method parse_page_constrained() , that parses a page similar to how the aforementioned constrained method parses a line - it stacks images of lines on top of each other and returns the image of a page and leftover text, filling in with whitespace as needed. The method parse_page_constrained() handles stacking leftover words from the previous line into the new line (this happens because you can type many more characters in a line than you would normally write on a page), and text alignment. The class DocumentParser inherits from PageParser and parses the whole document. It uses the python-docx module to read text and metadata from the document, then relays this information to PageParser methods. These methods return the pages of the document in handwriting which are then compiled into a PDF.","title":"Architecture"},{"location":"generating_hashes/","text":"Generating Handwriting Presently, the basis for generating handwriting in HandWriter is restrictively static and it is highly desirable that future releases generalize this procedure by automating the extraction of letter images of a person's handwriting (perhaps with the use of machine learning). This section elucidates the steps that were taken to manually feed a handwriting sample to the application, to guide the automation of these steps in the future. Data Gathering and Serialization A sample of handwriting was obtained with constraints imposed - Multiple instances of each letter and symbol were written in a fixed grid. Each cell within a grid was divided into 3 parts vertically in the ratio of 1:1:2, and letters were written accordingly. This can be seen in the difference between the letters \u2018a\u2019, 'd\u2019, and \u2018y\u2019. Letters were extracted from the grid using opencv, and the data was processed and cleaned. Finally the matrix representation of each image was stored in a hashtable that maps an instance of a character to its image. Each letter has five instances (such as 'a1.jpg' .. 'a5.jpg'). The key of hashtable is like 'a1.jpg' (that is, the name of the image file), and its value is the 8-bit integer matrix representation of the corresponding image. There is only one whitespace stored as 'whitespace.jpg'. Symbols are stored like '(1.jpg', '(2.jpg' .. '(5.jpg' Inverted and double inverted commas are stored as 'inv1.jpg' .. 'inv5.jpg' and 'dinv1.jpg' to 'dinv5.jpg' respectively. Further there is some special consideration given in LineParser when these symbols are converted, because there are actually 3 characters each that can represent these symbols. This hashtable was serialized with pickle and exported as \u2018hashes.pickle\u2019 Adding a new handwriting Due to the architecture of handwriter, changing or adding a new handwriting is simply a matter of changing the underlying hashes.pickle with images of the new handwriting. Store this new pickled hashtable file in src/main/resources and change the hashes path variable in ParserThread object in main.py . It is important that the new hashes file has keys formatted exactly as outlined above, as the LineParser class expects this.","title":"Generating Handwriting"},{"location":"generating_hashes/#generating-handwriting","text":"Presently, the basis for generating handwriting in HandWriter is restrictively static and it is highly desirable that future releases generalize this procedure by automating the extraction of letter images of a person's handwriting (perhaps with the use of machine learning). This section elucidates the steps that were taken to manually feed a handwriting sample to the application, to guide the automation of these steps in the future.","title":"Generating Handwriting"},{"location":"generating_hashes/#data-gathering-and-serialization","text":"A sample of handwriting was obtained with constraints imposed - Multiple instances of each letter and symbol were written in a fixed grid. Each cell within a grid was divided into 3 parts vertically in the ratio of 1:1:2, and letters were written accordingly. This can be seen in the difference between the letters \u2018a\u2019, 'd\u2019, and \u2018y\u2019. Letters were extracted from the grid using opencv, and the data was processed and cleaned. Finally the matrix representation of each image was stored in a hashtable that maps an instance of a character to its image. Each letter has five instances (such as 'a1.jpg' .. 'a5.jpg'). The key of hashtable is like 'a1.jpg' (that is, the name of the image file), and its value is the 8-bit integer matrix representation of the corresponding image. There is only one whitespace stored as 'whitespace.jpg'. Symbols are stored like '(1.jpg', '(2.jpg' .. '(5.jpg' Inverted and double inverted commas are stored as 'inv1.jpg' .. 'inv5.jpg' and 'dinv1.jpg' to 'dinv5.jpg' respectively. Further there is some special consideration given in LineParser when these symbols are converted, because there are actually 3 characters each that can represent these symbols. This hashtable was serialized with pickle and exported as \u2018hashes.pickle\u2019","title":"Data Gathering and Serialization"},{"location":"generating_hashes/#adding-a-new-handwriting","text":"Due to the architecture of handwriter, changing or adding a new handwriting is simply a matter of changing the underlying hashes.pickle with images of the new handwriting. Store this new pickled hashtable file in src/main/resources and change the hashes path variable in ParserThread object in main.py . It is important that the new hashes file has keys formatted exactly as outlined above, as the LineParser class expects this.","title":"Adding a new handwriting"}]}